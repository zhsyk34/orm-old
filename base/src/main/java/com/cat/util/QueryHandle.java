package com.cat.util;

import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;

/**
 * Created by Archimedes on 2016/7/6.
 */
public class QueryHandle {

	//getParameterType是否可用
	private volatile boolean pmtAbled = true;

	public PreparedStatement preparedStatement(Connection connection, String sql) throws SQLException {
		return connection.prepareStatement(sql);
	}

	public PreparedStatement preparedStatement(Connection connection, String sql, int autoGeneratedKeys) throws SQLException {
		return connection.prepareStatement(sql, autoGeneratedKeys);
	}

	public void fillStatement(PreparedStatement preparedStatement, Object... params) throws SQLException {
		if (params == null || params.length == 0) {
			return;
		}
		ParameterMetaData parameterMetaData = null;

		if (pmtAbled) {
			parameterMetaData = preparedStatement.getParameterMetaData();

			int required = parameterMetaData.getParameterCount();
			int actual = params.length;

			if (required != actual) {
				throw new RuntimeException("Wrong number of parameters: expected " + required + ", was given " + actual);
			}
		}

		if (params == null || params.length == 0) {
			return;
		}

		for (int i = 0; i < params.length; i++) {
			Object param = params[i];

			if (param != null) {
				preparedStatement.setObject(i + 1, param);
			} else {
				int sqlType = Types.VARCHAR;
				if (pmtAbled) {
					try {
						sqlType = parameterMetaData.getParameterType(i + 1);
					} catch (SQLException e) {
						pmtAbled = false;//说明不可用...
					}
				}
				preparedStatement.setNull(i + 1, sqlType);
			}
		}
	}

	public void fillStatement(PreparedStatement preparedStatement, Object bean, String... propertyNames) throws SQLException {
		if (propertyNames == null || propertyNames.length == 0) {
			return;
		}

		PropertyDescriptor[] properties;

		try {
			properties = Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors();
		} catch (IntrospectionException e) {
			throw new RuntimeException("Couldn't introspect bean " + bean.getClass(), e);
		}

		PropertyDescriptor[] actual = new PropertyDescriptor[propertyNames.length];
		for (int i = 0; i < propertyNames.length; i++) {
			String propertyName = propertyNames[i];

			if (propertyName == null) {
				throw new NullPointerException("propertyName can't be null: " + i);
			}

			boolean found = false;//是否有相应的属性
			for (int j = 0; j < properties.length; j++) {
				PropertyDescriptor property = properties[j];
				if (propertyName.equals(property.getName())) {
					actual[i] = property;
					found = true;
					break;
				}
			}

			if (!found) {
				throw new RuntimeException("Couldn't find bean property: " + bean.getClass() + " " + propertyName);
			}
		}

		this.fillStatement(preparedStatement, bean, actual);
	}

	public void fillStatement(PreparedStatement preparedStatement, Object bean, PropertyDescriptor[] properties) throws SQLException {
		Object[] params = new Object[properties.length];
		for (int i = 0; i < properties.length; i++) {
			PropertyDescriptor property = properties[i];
			Method method = property.getReadMethod();

			if (method == null) {
				throw new RuntimeException("No read method for bean property " + bean.getClass() + " " + property.getName());
			}

			try {
				method.invoke(bean);
			} catch (IllegalAccessException | InvocationTargetException e) {
				throw new RuntimeException("Couldn't invoke method: " + method, e);
			}
		}
		this.fillStatement(preparedStatement, params);
	}

	public ResultSet execute(Connection connection, String sql, Object... params) throws SQLException {
		PreparedStatement preparedStatement = this.preparedStatement(connection, sql);
		this.fillStatement(preparedStatement, params);

		return preparedStatement.executeQuery();
	}
}
